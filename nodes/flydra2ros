#!/usr/bin/env python

import threading
import numpy as np
import warnings

# ROS imports
import roslib; roslib.load_manifest('strawlab_freeflight_experiments')
from ros_flydra.msg import flydra_mainbrain_super_packet
from geometry_msgs.msg import Pose, Quaternion
from std_msgs.msg import UInt32
import rospy

import display_client

IMPOSSIBLE_OBJ_ID = 0

class Node(object):
    def __init__(self):
        rospy.init_node('flydra2ros')
        rospy.Subscriber("flydra_mainbrain_super_packets",
                         flydra_mainbrain_super_packet,
                         self.on_flydra_mainbrain_super_packets)
        rospy.Subscriber("lock_object",
                         UInt32,
                         self.on_lock_object)

        self.timeout = 0.5 # seconds before object is dropped
        latencies = [
            ('no_prediction',   'pose'),
            (0,    'pose_now'),
            (0.02, 'pose_20_msec' ),
            ]
        self.latency_pubs = {}
        for (latency_sec, topic_name) in latencies:
            self.latency_pubs[latency_sec] = rospy.Publisher(topic_name, Pose,
                                                             tcp_nodelay=True)

        self._ori = Quaternion(0,0,0,1) # a valid orientation

        #self.lock = threading.Lock()
        self._clear_object('initialization')
        self._timer = rospy.Timer(rospy.Duration(1.0/200.0),
                                  self._send_updates)

    def _clear_object(self,reason):
        rospy.loginfo( reason )
        if 1:
        #with self.lock:
            self._current_obj_id = IMPOSSIBLE_OBJ_ID
            self._current_obj_start_mytime = rospy.get_time()
            self._current_obj_last_seen_mytime = 0
            self._current_obj_last_seen_acquire_stamp = None
            self._current_obj_last_seen_framenumber = 0
        self.pos_est = np.nan*np.zeros((3,))
        self.vel_est = np.nan*np.zeros((3,))

    def on_lock_object(self,msg):
        rospy.loginfo( 'request to lock obj_id %d'%(msg.data,) )

        if self._current_obj_id == msg.data:
            # we are already locked onto this object
            return

        if self._current_obj_id != IMPOSSIBLE_OBJ_ID:
            rospy.loginfo( 'request to stop lock obj_id %d (to lock %d)'%(self._current_obj_id,msg.data) )

        self._current_obj_id = msg.data
        self._current_obj_start_mytime = rospy.get_time()
        self._current_obj_last_seen_mytime = 0
        self._current_obj_last_seen_acquire_stamp = None
        self._current_obj_last_seen_framenumber = 0

    def run(self):
        r = rospy.Rate(10) # 10hz
        while not rospy.is_shutdown():
            # check for stale object ID
            if self._current_obj_id != IMPOSSIBLE_OBJ_ID:
                now = rospy.get_time()
                if 1:
                #with self.lock:
                    duration_without_new_data = now - self._current_obj_last_seen_mytime

                    data_t = self._current_obj_last_seen_acquire_stamp
                    if data_t is not None:
                        latency = now - data_t.to_sec()
                        print 'latency: %.1f msec'%(latency*1000.0,)

                if duration_without_new_data > self.timeout:
                    # data is too old. drop this object.
                    self._clear_object('timeout on obj_id %d'%self._current_obj_id)

            r.sleep()

    def _send_updates(self,evt=None):
        now = rospy.get_time()
        if 1:
        #with self.lock:
            acquire_stamp = self._current_obj_last_seen_acquire_stamp
            pos_est = self.pos_est
            vel_est = self.vel_est

        if acquire_stamp is not None:
            dt = now - acquire_stamp.to_sec()
        else:
            dt = 0.0

        for latency_sec, pub in self.latency_pubs.iteritems():
            # if pub.get_num_connections()==0:
            #     continue

            if latency_sec=='no_prediction':
                est = pos_est
            else:
                est = pos_est + vel_est*(dt+latency_sec)

            if np.isnan(est[0]):
                warnings.warn('nan position hack')
                est = 0, 0, 0.5
            
            msg = Pose()
            msg.position.x, msg.position.y, msg.position.z = est
            msg.orientation = self._ori
            pub.publish(msg)

    def in_volume_of_interest(self,position):
        return not (((position.z < 0.05) or (position.z > 0.95) ) or ( (position.x**2 + position.y**2) > 0.45**2))

    def on_flydra_mainbrain_super_packets(self,data):
        now = rospy.get_time()
        for packet in data.packets:
            framenumber = packet.framenumber
            acquire_stamp = packet.acquire_stamp
            for obj in packet.objects:
                update = False
                if self._current_obj_id == IMPOSSIBLE_OBJ_ID:
                    if self.in_volume_of_interest(obj.position):
                        # no object: lock on to the next available object
                        update = True
                        if 1:
                        #with self.lock:
                            self._current_obj_id = obj.obj_id
                            self._current_obj_start_mytime = now
                            update = True
                        rospy.loginfo( 'locked on to obj_id %d'%(obj.obj_id,) )

                elif self._current_obj_id == obj.obj_id:
                    update = True
                if update:
                    if 1:
                    #with self.lock:
                        if np.isnan( obj.position.x ):
                            # signal that object is lost
                            self._clear_object('object lost (nan position) on obj_id %d'%self._current_obj_id )
                        elif framenumber > self._current_obj_last_seen_framenumber: # only take most recent data

                            if self._current_obj_last_seen_acquire_stamp is not None:
                                assert acquire_stamp > self._current_obj_last_seen_acquire_stamp

                            self._current_obj_last_seen_mytime = now
                            self._current_obj_last_seen_acquire_stamp = acquire_stamp
                            self._current_obj_last_seen_framenumber = framenumber
                            self.pos_est = np.array( (obj.position.x,
                                                      obj.position.y,
                                                      obj.position.z))
                            self.vel_est = np.array( (obj.velocity.x,
                                                      obj.velocity.y,
                                                      obj.velocity.z))
                        self._send_updates() # send upon data receive to minimize lag

if __name__ == '__main__':
    n = Node()
    n.run()



